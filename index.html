<!DOCTYPE html>
<meta charset="utf-8" />
<title>AUS Research Clusters â€” Tree with Publication Popup</title>
<style>
  :root { --bg:#fff; --fg:#111; --muted:#6b7280; --border:#e5e7eb; }
  body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--fg); }
  /* Topnav */
  .topnav {
    position: sticky;
    top: 0;
    background: #fff;
    border-bottom: 1px solid var(--border);
    display: flex;
    gap: 16px;
    padding: 10px 16px;
    z-index: 2000;
  }
  .topnav a {
    text-decoration: none;
    color: #111;
    font-size: 14px;
    font-weight: 500;
  }
  .topnav a:hover {
    color: #007acc;
  }

  .controls { padding: 14px; background: #f9fafb; border-bottom: 1px solid var(--border); }
  
  .controls { padding: 14px; background: #f9fafb; border-bottom: 1px solid var(--border); }
  .controls label { margin-right: 20px; font-size: 14px; }
  .controls select, .controls input { margin-left: 8px; padding: 4px 8px; border: 1px solid var(--border); border-radius: 4px; }
  
  /* Popup styles */
  .popup-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: none; }
  .popup-content { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 8px; padding: 15px; max-width: 70%; max-height: 85%; overflow-y: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 1001; font-size: 11px; }
  .popup-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; border-bottom: 1px solid #eee; padding-bottom: 8px; }
  .popup-title { font-size: 14px; font-weight: bold; color: #333; }
  .popup-close { background: none; border: none; font-size: 20px; cursor: pointer; color: #666; }
  .popup-close:hover { color: #000; }
  .publication-item { margin-bottom: 8px; padding: 6px; border-left: 3px solid #007acc; background: #f9f9f9; }
  .publication-year { font-weight: bold; color: #007acc; margin-bottom: 4px; font-size: 12px; }
  .publication-title { font-size: 12px; line-height: 1.3; margin-bottom: 3px; }
  .publication-meta { font-size: 9px; color: #666; }
  .cluster-theme-info { font-size: 9px; color: #007acc; margin-top: 2px; font-weight: bold; }
  .author-clickable { cursor: pointer; text-decoration: underline; }
  .author-clickable:hover { color: #007acc; }
  svg { width: 100%; height: auto; display:block; }
</style>


<div class="topnav">
  <a href="./">Home</a>
  <a href="pages/table.html?dataset=table1">Table 1</a>
  <a href="pages/table.html?dataset=table2">Table 2</a>
</div>

<div class="controls">
  <label>
    Layout:
    <select id="layoutSelect">
      <option value="tree">Tree (Left-to-Right)</option>
      <option value="cluster">Cluster</option>
    </select>
  </label>
  <label>
    Min Papers:
    <input type="number" id="minPapers" value="1" min="1" max="50">
  </label>
  <button onclick="updateVisualization()">Update</button>
</div>

<!-- Popup for publications -->
<div class="popup-overlay" id="popupOverlay">
  <div class="popup-content">
    <div class="popup-header">
      <div class="popup-title" id="popupTitle">Author Publications</div>
      <button class="popup-close" onclick="closePopup()">&times;</button>
    </div>
    <div id="popupBody"></div>
  </div>
</div>

<div id="mount"></div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
let rawData = null;
let currentLayout = 'tree';
let minPapers = 1;

// Popup functions
function showAuthorPublications(authorData) {
  console.log("showAuthorPublications called with:", authorData);
  
  const popupTitle = document.getElementById('popupTitle');
  const popupBody = document.getElementById('popupBody');
  const popupOverlay = document.getElementById('popupOverlay');
  
  if (!popupTitle || !popupBody || !popupOverlay) {
    console.error("Popup elements not found!");
    return;
  }
  
  popupTitle.textContent = `${authorData.name} - Publications`;
  
  // Check if publication data exists
  if (!authorData.all_publications || !Array.isArray(authorData.all_publications)) {
    console.warn("No publication data found for author:", authorData);
    popupBody.innerHTML = `
      <div style="color: #666; font-size: 11px;">
        <strong>Author:</strong> ${authorData.name}<br>
        <strong>Department:</strong> ${authorData.department || 'Unknown'}<br>
        <strong>Papers in this theme:</strong> ${authorData.dominant_papers || 0}<br>
        <strong>Total papers:</strong> ${authorData.value || 0}<br><br>
        <div style="color: #ff6b35;">Publication details are not available. Please regenerate the data.</div>
      </div>`;
    popupOverlay.style.display = 'block';
    return;
  }

  // Use the complete cluster-theme mapping from the JSON
  let clusterThemeMap = {};
  if (rawData && rawData.complete_cluster_theme_mapping) {
    clusterThemeMap = rawData.complete_cluster_theme_mapping;
    console.log("Using complete cluster-theme mapping:", Object.keys(clusterThemeMap).length, "entries");
  } else {
    // Fallback: build from visible data
    console.log("No complete mapping found, building from visible data");
    if (rawData && rawData.children) {
      rawData.children.forEach(cluster => {
        if (cluster.children) {
          cluster.children.forEach(theme => {
            const clusterIdInt = parseInt(cluster.id);
            const themeIdInt = parseInt(theme.id);
            
            const mapping = {
              cluster_id: cluster.id,
              cluster_name: cluster.name.replace(/^\d+:\s*/, ''),
              theme_id: theme.id,
              theme_name: theme.name.replace(/^Theme \d+:\s*/, '')
            };
            
            clusterThemeMap[`${cluster.id}_${theme.id}`] = mapping;
            clusterThemeMap[`${clusterIdInt}_${themeIdInt}`] = mapping;
          });
        }
      });
    }
  }
  
  // Group publications by year
  const pubsByYear = {};
  authorData.all_publications.forEach(pub => {
    const year = pub.year || 'Unknown';
    if (!pubsByYear[year]) pubsByYear[year] = [];
    pubsByYear[year].push(pub);
  });
  
  // Sort years in descending order
  const sortedYears = Object.keys(pubsByYear).sort((a, b) => {
    if (a === 'Unknown') return 1;
    if (b === 'Unknown') return -1;
    return parseInt(b) - parseInt(a);
  });
  
  // Build HTML content
  let html = `<div style="margin-bottom: 8px; color: #666; font-size: 10px;">
    <strong>Total:</strong> ${authorData.all_publications.length} | 
    <strong>This theme:</strong> ${authorData.theme_publications ? authorData.theme_publications.length : 0} | 
    <strong>Dept:</strong> ${authorData.department}
  </div>`;
  
  sortedYears.forEach(year => {
    html += `<div style="margin-bottom: 12px;">
      <h4 class="publication-year">${year} (${pubsByYear[year].length})</h4>`;
    
    pubsByYear[year].forEach(pub => {
      const isInThisTheme = authorData.theme_publications && 
                           authorData.theme_publications.some(tp => tp.scopus_id === pub.scopus_id);
      const highlight = isInThisTheme ? 'border-left-color: #ff6b35; background: #fff3f0;' : '';
      
      // Try multiple key formats to find cluster/theme info
      const possibleKeys = [
        `${pub.cluster_id}_${pub.theme_id}`,
        `${parseInt(pub.cluster_id)}_${parseInt(pub.theme_id)}`
      ];
      
      let clusterThemeInfo = null;
      for (const key of possibleKeys) {
        if (clusterThemeMap[key]) {
          clusterThemeInfo = clusterThemeMap[key];
          break;
        }
      }
      
      html += `<div class="publication-item" style="${highlight}">
        <div class="publication-title">${pub.title}</div>
        <div class="publication-meta">
          ID: ${pub.scopus_id}
          ${isInThisTheme ? ' <span style="color: #ff6b35; font-weight: bold;">(Current)</span>' : ''}
        </div>`;
      
      if (clusterThemeInfo) {
        html += `<div class="cluster-theme-info">
          ðŸ“‚ ${clusterThemeInfo.cluster_name} â†’ ${clusterThemeInfo.theme_name}
        </div>`;
      } else {
        html += `<div class="cluster-theme-info" style="color: #999;">
          ðŸ“‚ Cluster ${pub.cluster_id} â†’ Theme ${pub.theme_id} (not found)
        </div>`;
      }
      
      html += `</div>`;
    });
    
    html += '</div>';
  });
  
  popupBody.innerHTML = html;
  popupOverlay.style.display = 'block';
}

function closePopup() {
  document.getElementById('popupOverlay').style.display = 'none';
}

// Close popup when clicking overlay
document.getElementById('popupOverlay').addEventListener('click', function(e) {
  if (e.target === this) {
    closePopup();
  }
});

// Load data and initialize
const timestamp = new Date().getTime();
fetch(`./clusters.json?v=${timestamp}`)
  .then(r => r.json())
  .then(data => {
    console.log("Loaded data:", data);
    console.log("Number of clusters:", data.children ? data.children.length : 0);
    
    if (data.children) {
      data.children.forEach((cluster, i) => {
        console.log(`Cluster ${i+1}: ${cluster.name} (${cluster.children ? cluster.children.length : 0} themes)`);
        if (cluster.children) {
          cluster.children.forEach((theme, j) => {
            console.log(`  Theme ${j+1}: ${theme.name} (${theme.children ? theme.children.length : 0} authors)`);
            if (theme.children && theme.children.length > 0) {
              const sampleAuthor = theme.children[0];
              console.log(`    Sample author:`, sampleAuthor.name);
              console.log(`    Author has ${sampleAuthor.all_publications ? sampleAuthor.all_publications.length : 0} total publications`);
              console.log(`    Author has ${sampleAuthor.theme_publications ? sampleAuthor.theme_publications.length : 0} theme publications`);
            }
          });
        }
      });
    }
    
    rawData = data;
    updateVisualization();
  })
  .catch(err => {
    console.error("Error loading data:", err);
    document.getElementById("mount").innerHTML = `
      <div style="padding: 20px; text-align: center;">
        <h3>Error loading data</h3>
        <p>Make sure clusters.json is available and valid.</p>
        <p>Error: ${err.message}</p>
        <button onclick="location.reload()">Reload Page</button>
      </div>`;
  });

function updateVisualization() {
  const layoutSelect = document.getElementById('layoutSelect');
  const minPapersInput = document.getElementById('minPapers');
  
  currentLayout = layoutSelect.value;
  minPapers = parseInt(minPapersInput.value) || 1;
  
  if (!rawData) {
    console.log("No raw data available");
    return;
  }
  
  console.log("Updating visualization with layout:", currentLayout, "minPapers:", minPapers);
  
  // Clear previous visualization
  document.getElementById("mount").innerHTML = "";
  
  if (currentLayout === 'tree') {
    renderTreeVisualization();
  } else {
    renderClusterVisualization();
  }
}

function filterDataByMinPapers(data) {
  // Filter authors by minimum paper count IN THEIR DOMINANT CLUSTER/THEME
  const filtered = JSON.parse(JSON.stringify(data)); // Deep clone
  
  console.log("Before filtering:", filtered.children ? filtered.children.length : 0, "clusters");
  
  filtered.children = filtered.children.map(cluster => {
    const originalThemes = cluster.children ? cluster.children.length : 0;
    
    cluster.children = cluster.children.map(theme => {
      const originalAuthors = theme.children ? theme.children.length : 0;
      theme.children = theme.children.filter(author => {
        // Use dominant_papers (papers in this theme) instead of total papers
        const papersInThisTheme = author.dominant_papers || 0;
        return papersInThisTheme >= minPapers;
      });
      
      console.log(`  Theme ${theme.name}: ${originalAuthors} -> ${theme.children.length} authors (minPapers in theme: ${minPapers})`);
      return theme;
    }).filter(theme => theme.children.length > 0);
    
    console.log(`Cluster ${cluster.name}: ${originalThemes} -> ${cluster.children.length} themes`);
    return cluster;
  }).filter(cluster => cluster.children.length > 0);
  
  console.log("After filtering:", filtered.children.length, "clusters");
  
  return filtered;
}

function renderTreeVisualization() {
  const filteredData = filterDataByMinPapers(rawData);
  
  // Get clusters
  const clusters = filteredData.children || [];
  const palette = d3.schemeTableau10.concat(d3.schemeSet3 || []);
  const color = d3.scaleOrdinal(clusters.map(d => d.id), palette.slice(0, clusters.length));
  
  // Create container for multiple trees
  const containerDiv = document.createElement("div");
  containerDiv.style.display = "flex";
  containerDiv.style.flexDirection = "column";
  containerDiv.style.gap = "20px";
  containerDiv.style.padding = "20px";
  
  // Create a separate tree for each cluster
  clusters.forEach((cluster, clusterIndex) => {
    // Create individual tree data for this cluster
    const clusterTreeData = {
      name: cluster.name,
      type: 'cluster',
      id: cluster.id,
      cluster_id: cluster.id,
      children: cluster.children || []
    };
    
    // Tree layout for this cluster
    const root = d3.hierarchy(clusterTreeData);
    const treeWidth = 2200;
    const dx = 25;
    const dy = treeWidth / (root.height + 1);
    
    const tree = d3.tree().nodeSize([dx, dy]);
    root.sort((a, b) => {
      // Sort by type first (cluster > theme > author), then by name
      const typeOrder = { 'cluster': 1, 'theme': 2, 'author': 3 };
      const aType = typeOrder[a.data.type] || 4;
      const bType = typeOrder[b.data.type] || 4;
      
      if (aType !== bType) return d3.ascending(aType, bType);
      
      // For authors, sort by paper count (descending)
      if (a.data.type === 'author' && b.data.type === 'author') {
        return d3.descending(a.data.value || 0, b.data.value || 0);
      }
      
      return d3.ascending(a.data.name, b.data.name);
    });
    
    tree(root);
    
    let x0 = Infinity, x1 = -x0;
    root.each(d => { if (d.x > x1) x1 = d.x; if (d.x < x0) x0 = d.x; });
    const height = x1 - x0 + dx * 2;
    
    // Create SVG for this cluster
    const svg = d3.create("svg")
      .attr("width", treeWidth)
      .attr("height", height)
      .attr("viewBox", [-80, x0 - dx, treeWidth, height])
      .attr("style", "max-width: 100%; height: auto; font: 14px system-ui, -apple-system, Segoe UI, Roboto, Arial;");
    
    // Links
    svg.append("g")
      .attr("fill", "none")
      .attr("stroke-opacity", 0.5)
      .attr("stroke-width", 2)
      .selectAll("path")
      .data(root.links())
      .join("path")
        .attr("stroke", color(cluster.id))
        .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));
    
    // Nodes
    const node = svg.append("g")
      .attr("stroke-linejoin", "round")
      .attr("stroke-width", 4)
      .selectAll("g")
      .data(root.descendants())
      .join("g")
        .attr("transform", d => `translate(${d.y},${d.x})`)
        .style("cursor", d => d.data.type === 'author' ? 'pointer' : 'default')
        .on("click", function(event, d) {
          console.log("Node clicked:", d.data.type, d.data.name);
          if (d.data.type === 'author') {
            event.stopPropagation();
            console.log("Author clicked:", d.data);
            showAuthorPublications(d.data);
          }
        });
    
    node.append("circle")
      .attr("r", d => {
        if (d.data.type === 'cluster') return 8;
        if (d.data.type === 'theme') return 5;
        return 3;
      })
      .attr("fill", d => {
        if (d.data.type === 'cluster') return color(cluster.id);
        if (d.data.type === 'theme') return d3.color(color(cluster.id)).darker(0.5);
        return d3.color(color(cluster.id)).darker(1);
      })
      .attr("stroke", "white");
    
    node.append("text")
      .attr("dy", "0.31em")
      .attr("x", d => {
        if (d.data.type === 'cluster') return 15; 
        if (d.data.type === 'theme') return 12; 
        return 20;
      })
      .attr("text-anchor", "start")
      .attr("stroke", "white")
      .attr("stroke-width", d => d.data.type === 'author' ? 3 : 4)
      .attr("paint-order", "stroke")
      .style("font-weight", d => {
        if (d.data.type === 'cluster') return 700;
        if (d.data.type === 'theme') return 600;
        return 400;
      })
      .style("font-size", d => {
        if (d.data.type === 'cluster') return "24px";
        if (d.data.type === 'theme') return "18px";
        return "18px";
      })
      .style("fill", d => d.data.type === 'author' ? 'black' : 'black')
      .style("text-decoration", 'none')
      .text(d => {
        let text = d.data.name;
        if (d.data.type === 'cluster') {
          return text;
        } else if (d.data.type === 'theme') {
          return text.replace(/^Theme \d+: /, '');
        } else {
          return text;
        }
      })
      .each(function(d) {
        const text = d3.select(this);
        const maxLength = d.data.type === 'cluster' ? 70 : (d.data.type === 'theme' ? 50 : 40);
        const currentText = text.text();
        if (currentText.length > maxLength) {
          text.text(currentText.substring(0, maxLength) + "...");
        }
      });
    
    // Add the SVG to container
    containerDiv.appendChild(svg.node());
  });
  
  document.getElementById("mount").appendChild(containerDiv);
}

function renderClusterVisualization() {
  const filteredData = filterDataByMinPapers(rawData);
  
  // Get clusters  
  const clusters = filteredData.children || [];
  const palette = d3.schemeTableau10.concat(d3.schemeSet3 || []);
  const color = d3.scaleOrdinal(clusters.map(d => d.id), palette.slice(0, clusters.length));
  
  // Create container for multiple cluster visualizations
  const containerDiv = document.createElement("div");
  containerDiv.style.display = "flex";
  containerDiv.style.flexDirection = "column";
  containerDiv.style.gap = "20px";
  containerDiv.style.padding = "20px";
  
  // Create a separate force layout for each cluster
  clusters.forEach((cluster, clusterIndex) => {
    const nodes = [];
    const links = [];
    
    // Add cluster as central node
    nodes.push({
      id: `cluster_${cluster.id}`,
      name: cluster.name,
      type: 'cluster',
      cluster_id: cluster.id
    });
    
    cluster.children.forEach(theme => {
      // Add theme node
      const themeId = `theme_${theme.id}`;
      nodes.push({
        id: themeId,
        name: theme.name,
        type: 'theme',
        cluster_id: cluster.id,
        theme_id: theme.id
      });
      
      links.push({
        source: `cluster_${cluster.id}`,
        target: themeId
      });
      
      theme.children.forEach(author => {
        // Add author node
        const authorId = `author_${author.author_id}_${theme.id}`;
        nodes.push({
          id: authorId,
          name: author.name,
          type: 'author',
          cluster_id: cluster.id,
          theme_id: theme.id,
          value: author.value,
          all_publications: author.all_publications,
          theme_publications: author.theme_publications,
          department: author.department,
          dominant_papers: author.dominant_papers
        });
        
        links.push({
          source: themeId,
          target: authorId
        });
      });
    });
    
    // Create individual SVG for this cluster
    const width = 1400;
    const height = 600;
    
    const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [0, 0, width, height])
      .attr("style", "max-width: 100%; height: auto;");
    
    const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id).distance(d => {
        if (d.source.type === 'cluster') return 150;
        return 100;
      }))
      .force("charge", d3.forceManyBody().strength(d => {
        if (d.type === 'cluster') return -1000;
        if (d.type === 'theme') return -500;
        return -200;
      }))
      .force("center", d3.forceCenter(width / 2, height / 2))
      .force("collision", d3.forceCollide().radius(d => {
        if (d.type === 'cluster') return 30;
        if (d.type === 'theme') return 25;
        return 20;
      }));
    
    // Links
    const link = svg.append("g")
      .attr("stroke", color(cluster.id))
      .attr("stroke-opacity", 0.4)
      .selectAll("line")
      .data(links)
      .join("line")
      .attr("stroke-width", 2);
    
    // Nodes
    const node = svg.append("g")
      .selectAll("g")
      .data(nodes)
      .join("g")
      .style("cursor", d => d.type === 'author' ? 'pointer' : 'default')
      .on("click", function(event, d) {
        console.log("Cluster node clicked:", d.type, d.name);
        if (d.type === 'author') {
          event.stopPropagation();
          console.log("Author clicked in cluster view:", d);
          showAuthorPublications(d);
        }
      })
      .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));
    
    node.append("circle")
      .attr("r", d => {
        if (d.type === 'cluster') return 20;
        if (d.type === 'theme') return 15;
        return Math.max(8, Math.sqrt(d.value || 1) * 3);
      })
      .attr("fill", d => {
        if (d.type === 'cluster') return color(cluster.id);
        if (d.type === 'theme') return d3.color(color(cluster.id)).darker(0.5);
        return d3.color(color(cluster.id)).darker(1);
      })
      .attr("stroke", "white")
      .attr("stroke-width", 3);
    
    node.append("text")
      .attr("text-anchor", "middle")
      .attr("dy", "0.35em")
      .style("font-size", d => {
        if (d.type === 'cluster') return "24px";
        if (d.type === 'theme') return "20px";
        return "24px";
      })
      .style("font-weight", d => d.type === 'cluster' ? 700 : 400)
      .style("fill", d => d.type === 'author' ? '#007acc' : 'white')
      .style("stroke", "black")
      .style("stroke-width", "0.5px")
      .style("paint-order", "stroke")
      .style("text-decoration", d => d.type === 'author' ? 'underline' : 'none')
      .text(d => {
        let text = d.name;
        if (d.type === 'theme') {
          text = text.replace(/^Theme \d+: /, '');
        }
        const maxLength = d.type === 'author' ? 25 : 30;
        return text.length > maxLength ? text.substring(0, maxLength) + "..." : text;
      });
    
    simulation.on("tick", () => {
      link
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);
      
      node.attr("transform", d => `translate(${d.x},${d.y})`);
    });
    
    function dragstarted(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }
    
    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }
    
    function dragended(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }
    
    containerDiv.appendChild(svg.node());
  });
  
  document.getElementById("mount").appendChild(containerDiv);
}

// Event listeners
document.getElementById('layoutSelect').addEventListener('change', updateVisualization);
document.getElementById('minPapers').addEventListener('change', updateVisualization);
</script>